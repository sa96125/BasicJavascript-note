// 숫자가 담긴 배열과, 특정 숫자가 주어진다.
// 특정숫자의 갯수만큼 배열의 요소를 더한 합중 가장 큰 합을 반환하는 함수를 작성하여라.

// > [4, 2, 5, 8, 10, 3, 1], 3
// < 23

function subSumMax(arr, num) {
    let maxSum = 0;

    for (let i = 0; i < arr.length - num + 1; i++) {
        let temp = 0;
        for (let j = i; j < i + num; i++) {
            temp = arr[j];
        }
        if (maxSum < temp) {
            maxSum = temp;
        }
    }

    return maxSum;
}//--------------------------------------------------------------------------------------------------> 시간복잡도 O(n**2)

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                            R E F A C T O R I N G                                                  //
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

// 중복된 값이 존재하여 그 값을 더이상 더하지 않고, 새로운 값과 끝의 값만을 추가,삭제하여 쓸때 없는 계산을 줄였다.
// 진짜 와.. 감탄스럽기도 한데, 리팩토링을 하다보니든 생각이 하나의 공식처럼 
// 규칙적인 공식에 중복되는 값을 제거하면 훨씬 좋은 효율이 만들어진다.
function SlidingWindowPattern(arr, num) {
    let maxSum;
    let tempSum;

    for (let i = 0; i < num; i++) {
        maxSum += arr[i];
    }

    for (let i = num; i < arr.length - 1; i++) {
        tempSum = maxSum + arr[i] - arr[i - num];
        maxSum = Math.max(tempSum, maxSum);
    }

    return maxSum;
}//---------------------------------------------------------------------------------------------------->  시간복잡도 O(n)
